# -*- coding: utf-8 -*-
"""THGNN generate_relation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10kuVqfKOhcGQjkLYZIzzeBvO_ijjwL_-
"""

# from google.colab import drive
# drive.mount('/content/drive')



#data_directory = "/content/drive/MyDrive/Histdata/"

import pandas as pd

# df = pd.read_csv('/content/drive/MyDrive/allfields_merged_df.csv')

df = pd.read_csv('/mnt/data/sriram.kovela/total_df.csv')

# last_row = df.iloc[-1]
# print(last_row)



# print(len(set(df['date'])))

# def normalize_column(column):
#     return (column - column.min()) / (column.max() - column.min())

# final_df = pd.DataFrame()

# # Get the list of unique 'tic' values
# unique_tics = df['tic'].unique()

# # Iterate over each 'tic'
# for tic in unique_tics:
#     # Slice the DataFrame for the current 'tic'
#     df_tic = df[df['tic'] == tic]

#     # Normalize the relevant columns
#     normalized_tic = df_tic[['open', 'high', 'low', 'close', 'upperband', 'middleband', 'lowerband', 'moving_averages_list', 'cashflow']].apply(normalize_column)

#     # Add the 'tic' column back to the normalized DataFrame
#     normalized_tic['tic'] = df_tic['tic'].values
#     normalized_tic['date'] = df_tic['date'].values

#     # Append the normalized data to the final DataFrame
#     final_df = pd.concat([final_df, normalized_tic], ignore_index=True)

#final_df.to_csv('/content/drive/MyDrive/norm_2016.csv')

df1 = pd.read_csv('/mnt/data/sriram.kovela/norm_2016_mean.csv')

# print(final_df)

import pandas as pd
import os

#df1 = pd.read_json(os.path.join(data_directory, "norm_weekly_2018.json"), lines=True)
#df1 = df1.rename(columns={'rr': 'label'})

print(df1)

# target_date = '2020-02-13'
# target_stock = 'ADBE'

# # Slice the DataFrame up to the specified date and stock
# sliced_df = df[(df['tic'] == 'CI') & (df['tic'] == 'AAPL')]

# last_row = sliced_df.iloc[-1]
# print(last_row)

# print(len(set(sliced_df['date'])))

# stock_counts = df.groupby('tic').size()

# # Display the result
# print(stock_counts)

date_unique=df1['date'].unique()
stock_trade_data=date_unique.tolist()
stock_trade_data.sort()
print(stock_trade_data[0])

import datetime

import time
import pickle
import multiprocessing as mp
import numpy as np
import pandas as pd
from tqdm import tqdm

feature_cols = ['high','low','close','open']

def cal_pccs(x, y, n):
    sum_xy = np.sum(np.sum(x*y))
    sum_x = np.sum(np.sum(x))
    sum_y = np.sum(np.sum(y))
    sum_x2 = np.sum(np.sum(x*x))
    sum_y2 = np.sum(np.sum(y*y))
    pcc = (n*sum_xy-sum_x*sum_y)/np.sqrt((n*sum_x2-sum_x*sum_x)*(n*sum_y2-sum_y*sum_y))
    return pcc

def calculate_pccs(xs, yss, n):
    print("!!!!!!!!!!!!!!!!!!!!inside pccs")
    result = []
    for name in yss:
        ys = yss[name]
        tmp_res = []
        for pos, x in enumerate(xs):
            y = ys[pos]
            tmp_res.append(cal_pccs(x, y, n))
        result.append(tmp_res)
    return np.mean(result, axis=1)

def stock_cor_matrix(ref_dict, codes, n, processes=1):
    print("!!!!!!!!!!!!!!!!!!!!!!")
    if processes > 1:
        
        pool = mp.Pool(processes=processes)
        print("pool is ", pool)
        args_all = [(ref_dict[code], ref_dict, n) for code in codes]
        print("args_all", args_all)
        results = [pool.apply_async(calculate_pccs, args=args) for args in args_all]
        print("results are ", results)
        output = [o.get() for o in results]
        data = np.stack(output)
        return pd.DataFrame(data=data, index=codes, columns=codes)
    data = np.zeros([len(codes), len(codes)])
    print("THE CODES INSIDE ARE",len( codes) )
    for i in tqdm(range(len(codes))):
        data[i, :] = calculate_pccs(ref_dict[codes[i]], ref_dict, n)
    return pd.DataFrame(data=data, index=codes, columns=codes)

#path1 = "/content/drive/MyDrive/THGNN/csi300.pkl"
#df1 = pickle.load(open(path1, 'rb'), encoding='utf-8')
#print(df1)
#df1.to_csv('/content/drive/MyDrive/stockdata_out.csv')


#filtered_df = df_data.loc[(df_data['date'] >= '2018-01-1')
    #                 & (df_data['date'] < '2018-12-12')]

#print(len(filtered_df))


#prev_date_num Indicates the number of days in which stock correlation is calculated
prev_date_num = 1036
date_unique=df1['date'].unique()
stock_trade_data=date_unique.tolist()
stock_trade_data.sort()
print(type(stock_trade_data[0]))
stock_num=len(set(df1['tic']))
#dt is the last trading day of each month
date=['2020-02-13','2024-03-28']
date_2 = ['2016-01-04','2020-02-18']
print(type(date[0]))
# for i in ['2020','2021','2022']:
#     for j in ['01','02','03','04','05','06','07','08','09','10','11','12']:
#         stock_m=[k for k in stock_trade_data if k>i+'-'+j and k<i+'-'+j+'-32']
#         dt.append(stock_m[-1])
df1['date']=df1['date'].astype('datetime64')



for i in range(len(date)):
    print(i)
    df2 = df1.copy()
    end_data = date[i]
    start_data = date_2[i]
    #start_data = stock_trade_data[stock_trade_data.index(end_data)-(prev_date_num - 1)]
    df2 = df2.loc[df2['date'] <= end_data]
    df2 = df2.loc[df2['date'] >= start_data]
    #print("df2 is ", df2)
    symbol = sorted(list(set(df2['tic'].values.tolist())))
    print("symbol !!!!!!!!!!!!!!!!!!",len( symbol))
    test_tmp = {}
    print(len(symbol))
    for j in tqdm(range(len(symbol))):
        df3 = df2.loc[df2['tic'] == symbol[j]]
        y = df3[feature_cols].values
        print("y is !!!!!!!!!!!!", y.T.shape[1])
        if (j >200):
           print("j",j)
           print(y.T.shape[1])
           print(prev_date_num)
        if y.T.shape[1] == prev_date_num:
            
           test_tmp[symbol[j]] = y.T
        else:
           print("@@@@@@@@@@@@@@@@",symbol[j])
           print(y) 
    t1 = time.time()
    print("!!!!!!!!!!!!!!!!",len(test_tmp.keys()))
    result = stock_cor_matrix(test_tmp, list(test_tmp.keys()), prev_date_num, processes=1)
    print(len(result))
    print("result outside stock cor matrix", result)
    result=result.fillna(0)
    rows, columns = result.shape
    print("Number of rows:", rows)
    print("Number of columns:", columns)
    
    for i in range(0,stock_num-1):
        print(i)
        result.iloc[i,i]=1
    t2 = time.time()
    print('time cost', t2 - t1, 's')
    print(result)
    result.to_csv("/mnt/data/sriram.kovela/THGNN/relation/"+str(end_data)+".csv")
